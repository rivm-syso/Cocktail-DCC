PROGRAM MatureNuclides
   !
   ! Version 5 July 2023 for RIVM
   !
   ! This utility reads a nuclide vector at t=0 from file and a delay.
   ! It returns the aged cocktail.
   !
   USE libxmath
   USE libutil
   USE libendf
   USE libpinpoint

   IMPLICIT NONE

   TYPE(CocktailType) :: StartCocktail,OutCocktail,CocktailBefore,CocktailAfter
   CHARACTER(DefaultLength) :: FName,TheDirectory,TheFile,TimeStampString,TimeUnitString,ProgenyString,&
   & DatasetString
   REAL(Float), DIMENSION(0:NStartingTimes,MaxNuclides) :: MyActivity,MyRelevantActivity
   INTEGER :: NArguements,iLocX,iDelay,iNuclide,NRelevantNuclides,jNuclide,iMother,iDaughter,iPinpoint,iElement
   REAL(Float) :: NSecondsDelay,LocX,Alpha,x,Ln2
   LOGICAL, DIMENSION(MaxNuclides) :: IsRelatedToCocktail
   CHARACTER(10), DIMENSION(MaxNuclides) :: MyName
   LOGICAL :: WithProgeny,UseICRP,MakeWholeSeries
   INTEGER, DIMENSION(MaxNuclides) :: MyNuclide
   !
   ! Get commmand line arguement:
   !
   Ln2 = LOG(2._Float)

   NArguements = IARGC()

   IF (.NOT.((NArguements.EQ.3).OR.(NArguements.EQ.5))) THEN
      WRITE(*,'(A)') 'Call:'
      WRITE(*,*)
      WRITE(*,'(A)') 'mature_nuclides.exe <fname> <withprogeny/noprogeny> <Time step> <time unit> <ICRP/ENDF>'
      WRITE(*,*)
      WRITE(*,'(A)') 'where:'
      WRITE(*,'(A)') '<fname> is the name of a file with the nuclide vector at t=0'
      WRITE(*,'(A)') 'Choose 1 option of <withprogeny/noprogeny> for in/exclusion of progeny'
      WRITE(*,'(A)') '<Time step> is a real value indicating the delay, '
      WRITE(*,'(A)') '<Time unit> can be year, week, day, hour, minute or second,'
      WRITE(*,'(A)') '<ICRP/ENDF> indicates which nuclide dataset should be used,'
      WRITE(*,*)
      WRITE(*,'(A)') 'or:'
      WRITE(*,*)
      WRITE(*,'(A)') 'mature_nuclides.exe <fname> <withprogeny/noprogeny> <ICRP/ENDF>'
      WRITE(*,*)
      WRITE(*,'(A)') 'to generate a file with the time series for all nuclides, where:'
      WRITE(*,'(A)') '<fname> is the name of a file with the nuclide vector at t=0'
      WRITE(*,'(A)') 'Chose 1 option of <withprogeny/noprogeny> for in/exclusion of progeny,'
      WRITE(*,'(A)') '<ICRP/ENDF> indicates which nuclide dataset should be used.'

      CALL EXIT()
   ENDIF

   CALL GETARG(1,FName)
   CALL GETARG(2,ProgenyString)
   CALL AllUpCase(ProgenyString)
   WithProgeny = (INDEX(ProgenyString,'NO').EQ.0)

   IF (WithProgeny) THEN
      WRITE(*,'(A)') 'Decay will include the generation of progeny!'
   ELSE
      WRITE(*,'(A)') 'Decay will NOT include the generation of progeny! Any decay is final loss!'
   ENDIF

   MakeWholeSeries = (NArguements.EQ.3)

   IF (MakeWholeSeries) THEN
      CALL GETARG(3,DatasetString)
      WRITE(*,'(A)') 'Going to construct time series for all nuclides!'
   ELSE
      CALL GETARG(3,TimeStampString)
      WRITE(*,'(A)') 'You specified the following TimeStampString: '//TRIM(TimeStampString)

      READ(TimeStampString,*) NSecondsDelay

      CALL GETARG(4,TimeUnitString)
      WRITE(*,'(A)') 'You specified the following TimeUnitString : '//TRIM(TimeUnitString)

      IF (INDEX(TimeUnitString,'year').GT.0) THEN
         NSecondsDelay = 365._Float*24._Float*3600._Float*NSecondsDelay
      ELSE IF (INDEX(TimeUnitString,'week').GT.0) THEN
         NSecondsDelay = 7._Float*24._Float*3600._Float*NSecondsDelay
      ELSE IF (INDEX(TimeUnitString,'day').GT.0) THEN
         NSecondsDelay = 24._Float*3600._Float*NSecondsDelay
      ELSE IF (INDEX(TimeUnitString,'hour').GT.0) THEN
         NSecondsDelay = 3600._Float*NSecondsDelay
      ELSE IF (INDEX(TimeUnitString,'minute').GT.0) THEN
         NSecondsDelay = 60._Float*NSecondsDelay
      ELSE IF (INDEX(TimeUnitString,'second').EQ.0) THEN
         WRITE(*,'(A)') 'Wrong TimeUnitString: "'//TRIM(TimeUnitString)//'"'
         CALL EXIT()
      ENDIF
      CALL GETARG(5,DatasetString)
      WRITE(*,'(A,EN20.10,A)') 'Delay '//TRIM(TimeStampString)//TRIM(TimeUnitString)//' is ',NSecondsDelay,' seconds'
   ENDIF ! 2 or 3 parameters

   CALL AllUpCase(DatasetString)
   UseICRP = (INDEX(DatasetString,'ICRP').GT.0)

   IF (UseICRP) THEN
      WRITE(*,'(A)') 'Going to use the nuclide dataset from ICRP-107!'
   ELSE
      WRITE(*,'(A)') 'Going to use the nuclide dataset from ENDF-VIII!'
   ENDIF

   WRITE(*,*)
   !
   ! Initialize
   !
   CALL InitLibPinPoint(UseICRP)
   !
   ! Specify source term at t=0:
   !
   CALL ReadRIVMSourceTermFile(FName,StartCocktail)
   !
   ! Show which nuclide in the cocktail is generated by which other nuclide:
   !
   iPinPoint = 1

   DO iNuclide = 1,NNuclides
      DO iElement = 1,TransitionMatrix(iPinpoint)%N
         iMother = TransitionMatrix(iPinpoint)%Element(iElement)%i
         iDaughter = TransitionMatrix(iPinpoint)%Element(iElement)%j
         x = TransitionMatrix(iPinpoint)%Element(iElement)%x
         IF ((iDaughter.EQ.iNuclide)&
         &    .AND.(StartCocktail%x(iMother).GT.0._Float)&
         &    .AND.(iMother.NE.iDaughter)) THEN
            WRITE(*,'(A,A,A,A,A,F15.10)') 'Nuclide ',NuclideSpecs(iDaughter)%NuclideName,&
            & ' is generated by ',&
            & NuclideSpecs(iMother)%NuclideName,' with element ',x
         ENDIF ! Found a sparse matrix element with the present nuclide as daughter
      ENDDO ! Sparse matrix elements
   ENDDO ! loop over nuclides that candidate as progeny

   WRITE(*,*)
   !
   ! Now do the actual ageing
   !
   WRITE(*,'(A)') 'Constructing matured nuclide set for cocktail "'//TRIM(StartCocktail%MyName)&
   & //'" in directory "'//TRIM(StartCocktail%MyDirectory)//'"'

   IsRelatedToCocktail = .FALSE.
   !
   ! Check which nuclides can be expected
   !
   MyActivity = 0._Float
   MyNuclide = 0

   DO iDelay = 0,NStartingTimes
      IF (iDelay.EQ.0) THEN
         OutCocktail = StartCocktail
      ELSE
         CALL MatureCocktail(StartCocktail,TransitionMatrix(iDelay),WithProgeny,OutCocktail)
      ENDIF

      DO iNuclide = 1,NNuclides
         MyActivity(iDelay,iNuclide) = OutCocktail%x(iNuclide)
         IsRelatedToCocktail(iNuclide) = IsRelatedToCocktail(iNuclide).OR.(MyActivity(iDelay,iNuclide).GT.0._Float)
      ENDDO ! loop over nuclides
   ENDDO ! loop over timsteps

   NRelevantNuclides = 0
   DO iNuclide = 1,NNuclides
      IF (IsRelatedToCocktail(iNuclide)) THEN
         NRelevantNuclides = NRelevantNuclides + 1
         MyName(NRelevantNuclides) = NuclideSpecs(iNuclide)%NuclideName
         MyNuclide(NRelevantNuclides) = iNuclide
      ENDIF
   ENDDO ! loop over nuclides
   WRITE(*,'(A,I0,A)') 'Found ',NRelevantNuclides,' relevant nuclides!'

   MyRelevantActivity = 0._Float

   DO iDelay = 0,NStartingTimes
      jNuclide = 0
      DO iNuclide = 1,NNuclides
         IF (IsRelatedToCocktail(iNuclide)) THEN
         jNuclide = jNuclide + 1
         MyRelevantActivity(iDelay,jNuclide) = MyActivity(iDelay,iNuclide)
         ENDIF
      ENDDO ! loop over nuclides
   ENDDO ! loop over delays

   IF (MakeWholeSeries) THEN
      IF (WithProgeny) THEN
         IF (UseICRP) THEN
            FName = TRIM(StartCocktail%MyName)//'_with_ICRP_series.dat'
         ELSE
            FName = TRIM(StartCocktail%MyName)//'_with_ENDF_series.dat'
         ENDIF
      ELSE
         IF (UseICRP) THEN
            FName = TRIM(StartCocktail%MyName)//'_without_ICRP_series.dat'
         ELSE
            FName = TRIM(StartCocktail%MyName)//'_without_ENDF_series.dat'
         ENDIF
      ENDIF

      OPEN(ScratchFile,FILE=FNAME,FORM='FORMATTED',ACTION='WRITE')

      WRITE(ScratchFile,'(A,1X,1300A12)') 'Time[s]     ',(MyName(jNuclide),jNuclide = 1,NRelevantNuclides)

      DO iDelay = 0,NStartingTimes
         WRITE(ScratchFile,'(EN11.2,1300(1X,EN11.2))') AvailableDelay(iDelay),&
         & (MyRelevantActivity(iDelay,jNuclide),jNuclide = 1,NRelevantNuclides)

         !
         ! !!!!!!!!!! The line below is a hack to write amounts instead of activities !!!!!!!!!!!!!!!!!!
         !
         !       WRITE(ScratchFile,'(EN11.2,1300(1X,EN11.2))') AvailableDelay(iDelay),&
         !	   & (     MyRelevantActivity(iDelay,jNuclide)/(Ln2/NuclideSpecs(MyNuclide(jNuclide))%HalfTime),&
         !	   & jNuclide = 1,NRelevantNuclides)
      ENDDO ! loop over delays

      CLOSE(ScratchFile)
   ELSE
      !
      ! Construct mature cocktail on the basis of the nearest pinpoint, which are 15% in delay apart.
      !
      LocX = 1._Float + LOG(NSecondsDelay/FirstDelay)/LOG(DelayGrowthFactor)
      iLocX = NINT(LocX)

      CALL MatureCocktail(StartCocktail,TransitionMatrix(iLocX  ),WithProgeny,CocktailBefore)
      CALL MatureCocktail(StartCocktail,TransitionMatrix(iLocX+1),WithProgeny,CocktailAfter )

      Alpha = (AvailableDelay(iLocX+1)-NSecondsDelay)/(AvailableDelay(iLocX+1)-AvailableDelay(iLocX))

      OutCocktail%MyName = StartCocktail%MyName
      OutCocktail%MyDirectory = StartCocktail%MyDirectory
      DO iNuclide = 1,NNuclides
         OutCocktail%x(iNuclide) = Alpha*CocktailBefore%x(iNuclide) &
         &                      + (1._Float-Alpha)*CocktailAfter%x(iNuclide)
      ENDDO

      IF (WithProgeny) THEN
         IF (UseICRP) THEN
            FName = '_with_ICRP_'//TRIM(TimeStampString)//'_'//TRIM(TimeUnitString)
         ELSE
            FName = '_with_ENDF_'//TRIM(TimeStampString)//'_'//TRIM(TimeUnitString)
         ENDIF
      ELSE
         IF (UseICRP) THEN
            FName = '_without_ICRP_'//TRIM(TimeStampString)//'_'//TRIM(TimeUnitString)
         ELSE
            FName = '_without_ENDF_'//TRIM(TimeStampString)//'_'//TRIM(TimeUnitString)
         ENDIF
      ENDIF

      CALL SaveCocktail2(OutCocktail,FName)

   ENDIF
END PROGRAM MatureNuclides